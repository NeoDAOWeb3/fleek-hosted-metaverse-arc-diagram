"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/metaverse-arc-diagram",{

/***/ "./pages/metaverse-arc-diagram.js":
/*!****************************************!*\
  !*** ./pages/metaverse-arc-diagram.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _antv_g6__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/g6 */ \"./node_modules/@antv/g6/es/index.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n// A metaverse arc diagram using Ant Visualization\n// This is a mono repo in Github also for templates\n// It is includes in the pages of the NextJS Fleek Template project. \n// It is a NextJS component.\n\n\nvar _this = undefined;\nvar _s = $RefreshSig$();\n// Move this into a config file\nvar colors = [\n    'rgb(91, 143, 249)',\n    'rgb(90, 216, 166)',\n    'rgb(93, 112, 146)',\n    'rgb(246, 189, 22)',\n    'rgb(232, 104, 74)',\n    'rgb(109, 200, 236)',\n    'rgb(146, 112, 202)',\n    'rgb(255, 157, 77)',\n    'rgb(38, 154, 153)',\n    'rgb(227, 137, 163)', \n];\n/* harmony default export */ __webpack_exports__[\"default\"] = (arcDiagram = _s(function(props) {\n    _s();\n    var arcDiagramData = props.arcDiagramData, arcDiagramStyles = props.arcDiagramStyles, arcDiagramFunctions = props.arcDiagramFunctions;\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), graph = ref[0], setGraph = ref[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        if (graph) {\n            var scaleNodeProp = function scaleNodeProp(nodes, propName, refPropName, dataRange, outRange) {\n                var outLength = outRange[1] - outRange[0];\n                var dataLength = dataRange[1] - dataRange[0];\n                nodes.forEach(function(n) {\n                    n[propName] = (n[refPropName] - dataRange[0]) * outLength / dataLength + outRange[0];\n                });\n            };\n            // Initial config of the graph\n            var container = document.getElementById('container');\n            var width = container.scrollWidth;\n            var height = container.scrollHeight || 500;\n            var graph1 = new _antv_g6__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Graph({\n                container: 'container',\n                width: width,\n                height: height,\n                linkCenter: true,\n                modes: {\n                    default: [\n                        {\n                            type: 'edge-tooltip',\n                            formatText: function formatText(model) {\n                                var text = 'source: ' + model.sourceName + '<br/> target: ' + model.targetName;\n                                return text;\n                            }\n                        }, \n                    ]\n                },\n                defaultNode: {\n                    style: {\n                        opacity: 0.8,\n                        lineWidth: 1,\n                        stroke: '#999'\n                    }\n                },\n                defaultEdge: {\n                    size: 1,\n                    color: '#e2e2e2',\n                    style: {\n                        opacity: 0.6,\n                        lineAppendWidth: 3\n                    }\n                }\n            });\n            graph1.on('edge:mouseenter', function(e) {\n                var edge = e.item;\n                graph1.setItemState(edge, 'hover', true);\n            });\n            graph1.on('edge:mouseleave', function(e) {\n                var edge = e.item;\n                graph1.setItemState(edge, 'hover', false);\n            });\n            if (true) window.onresize = function() {\n                if (!graph1 || graph1.get('destroyed')) return;\n                if (!container || !container.scrollWidth || !container.scrollHeight) return;\n                graph1.changeSize(container.scrollWidth, container.scrollHeight);\n            };\n            fetch('https://gw.alipayobjects.com/os/basement_prod/70cde3be-22e8-4291-98f1-4d5a5b75b62f.json').then(function(res) {\n                return res.json();\n            }).then(function(data) {\n                var origin = [\n                    width / 2,\n                    height / 2\n                ];\n                var radius = width < height ? width / 3 : height / 3;\n                var edges = data.edges;\n                var nodes = data.nodes;\n                var nodeMap = new Map();\n                var clusterMap = new Map();\n                var clusterId = 0;\n                var n1 = nodes.length;\n                var angleSep = Math.PI * 2 / n1;\n                nodes.forEach(function(node, i) {\n                    var angle = i * angleSep;\n                    node.x = radius * Math.cos(angle) + origin[0];\n                    node.y = radius * Math.sin(angle) + origin[1];\n                    node.angle = angle;\n                    nodeMap.set(node.id, node);\n                    // cluster\n                    if (node.cluster && clusterMap.get(node.cluster) === undefined) {\n                        clusterMap.set(node.cluster, clusterId);\n                        clusterId++;\n                    }\n                    var id = clusterMap.get(node.cluster);\n                    if (node.style) {\n                        node.style.fill = colors[id % colors.length];\n                    } else {\n                        node.style = {\n                            fill: colors[id % colors.length]\n                        };\n                    }\n                    // label\n                    node.label = node.name;\n                    node.labelCfg = {\n                        position: 'center',\n                        style: {\n                            rotate: angle,\n                            rotateCenter: 'lefttop',\n                            textAlign: 'start'\n                        }\n                    };\n                });\n                edges.forEach(function(edge) {\n                    edge.type = 'quadratic';\n                    var source = nodeMap.get(edge.source);\n                    var target = nodeMap.get(edge.target);\n                    edge.controlPoints = [\n                        {\n                            x: origin[0],\n                            y: origin[1]\n                        }, \n                    ];\n                    edge.color = source.style.fill;\n                    edge.sourceName = source.name;\n                    edge.targetName = target.name;\n                });\n                // map the value to node size\n                var maxValue = -9999, minValue = 9999;\n                nodes.forEach(function(n) {\n                    if (maxValue < n.value) maxValue = n.value;\n                    if (minValue > n.value) minValue = n.value;\n                });\n                var sizeRange = [\n                    3,\n                    30\n                ];\n                var sizeDataRange = [\n                    minValue,\n                    maxValue\n                ];\n                scaleNodeProp(nodes, 'size', 'value', sizeDataRange, sizeRange);\n                graph1.data(data);\n                graph1.render();\n            });\n        }\n    }, [\n        graph\n    ]);\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: \"container\",\n        style: {\n            width: '100%',\n            height: '100%'\n        },\n        __source: {\n            fileName: \"/Users/jonsenterfitt/NEODAO/metaverse-arc-diagram/pages/metaverse-arc-diagram.js\",\n            lineNumber: 172,\n            columnNumber: 9\n        },\n        __self: _this\n    }));\n}, \"guVkFVVSew6hH2g/XBdZM40Ur3I=\"));\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUUsQ0FBTSxPQUFFLENBQU8sUUFBRXNGLGFBQWEsRUFBRUQsU0FBUztnQkFFOUR4RixNQUFLLENBQUNtRCxJQUFJLENBQUNBLElBQUk7Z0JBQ2ZuRCxNQUFLLENBQUMwRixNQUFNO1lBQ2hCLENBQUM7UUFTVCxDQUFDO0lBQ0wsQ0FBQyxFQUFFLENBQUMxRjtRQUFBQSxLQUFLO0lBQUEsQ0FBQztJQUVWLE1BQU0sc0VBQ0QyRixDQUFHO1FBQUNwQixFQUFFLEVBQUMsQ0FBVztRQUFDekMsS0FBSyxFQUFFLENBQUM7WUFBQ2YsS0FBSyxFQUFFLENBQU07WUFBRUUsTUFBTSxFQUFFLENBQU07UUFBQyxDQUFDOzs7Ozs7OztBQUVwRSxDQUFDLG1DQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL21ldGF2ZXJzZS1hcmMtZGlhZ3JhbS5qcz82N2Q5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgbWV0YXZlcnNlIGFyYyBkaWFncmFtIHVzaW5nIEFudCBWaXN1YWxpemF0aW9uXG4vLyBUaGlzIGlzIGEgbW9ubyByZXBvIGluIEdpdGh1YiBhbHNvIGZvciB0ZW1wbGF0ZXNcbi8vIEl0IGlzIGluY2x1ZGVzIGluIHRoZSBwYWdlcyBvZiB0aGUgTmV4dEpTIEZsZWVrIFRlbXBsYXRlIHByb2plY3QuIFxuLy8gSXQgaXMgYSBOZXh0SlMgY29tcG9uZW50LlxuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBHNiBmcm9tICdAYW50di9nNic7XG5cbi8vIE1vdmUgdGhpcyBpbnRvIGEgY29uZmlnIGZpbGVcbmNvbnN0IGNvbG9ycyA9IFtcbiAgICAncmdiKDkxLCAxNDMsIDI0OSknLFxuICAgICdyZ2IoOTAsIDIxNiwgMTY2KScsXG4gICAgJ3JnYig5MywgMTEyLCAxNDYpJyxcbiAgICAncmdiKDI0NiwgMTg5LCAyMiknLFxuICAgICdyZ2IoMjMyLCAxMDQsIDc0KScsXG4gICAgJ3JnYigxMDksIDIwMCwgMjM2KScsXG4gICAgJ3JnYigxNDYsIDExMiwgMjAyKScsXG4gICAgJ3JnYigyNTUsIDE1NywgNzcpJyxcbiAgICAncmdiKDM4LCAxNTQsIDE1MyknLFxuICAgICdyZ2IoMjI3LCAxMzcsIDE2MyknLFxuXTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGFyY0RpYWdyYW0gPSAocHJvcHMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGFyY0RpYWdyYW1EYXRhLFxuICAgICAgICBhcmNEaWFncmFtU3R5bGVzLFxuICAgICAgICBhcmNEaWFncmFtRnVuY3Rpb25zLFxuICAgIH0gPSBwcm9wcztcblxuICAgIGNvbnN0IFtncmFwaCwgc2V0R3JhcGhdID0gdXNlU3RhdGUobnVsbCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWwgY29uZmlnIG9mIHRoZSBncmFwaFxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjb250YWluZXIuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBjb250YWluZXIuc2Nyb2xsSGVpZ2h0IHx8IDUwMDtcblxuICAgICAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgRzYuR3JhcGgoe1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogJ2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxpbmtDZW50ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgbW9kZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlZGdlLXRvb2x0aXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFRleHQ6IGZ1bmN0aW9uIGZvcm1hdFRleHQobW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9ICdzb3VyY2U6ICcgKyBtb2RlbC5zb3VyY2VOYW1lICsgJzxici8+IHRhcmdldDogJyArIG1vZGVsLnRhcmdldE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdE5vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyM5OTknLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdEVkZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjZTJlMmUyJyxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVBcHBlbmRXaWR0aDogMyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmFwaC5vbignZWRnZTptb3VzZWVudGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlID0gZS5pdGVtO1xuICAgICAgICAgICAgICAgIGdyYXBoLnNldEl0ZW1TdGF0ZShlZGdlLCAnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JhcGgub24oJ2VkZ2U6bW91c2VsZWF2ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IGUuaXRlbTtcbiAgICAgICAgICAgICAgICBncmFwaC5zZXRJdGVtU3RhdGUoZWRnZSwgJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICB3aW5kb3cub25yZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JhcGggfHwgZ3JhcGguZ2V0KCdkZXN0cm95ZWQnKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnNjcm9sbFdpZHRoIHx8ICFjb250YWluZXIuc2Nyb2xsSGVpZ2h0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLmNoYW5nZVNpemUoY29udGFpbmVyLnNjcm9sbFdpZHRoLCBjb250YWluZXIuc2Nyb2xsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmZXRjaCgnaHR0cHM6Ly9ndy5hbGlwYXlvYmplY3RzLmNvbS9vcy9iYXNlbWVudF9wcm9kLzcwY2RlM2JlLTIyZTgtNDI5MS05OGYxLTRkNWE1Yjc1YjYyZi5qc29uJylcbiAgICAgICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYWRpdXMgPSB3aWR0aCA8IGhlaWdodCA/IHdpZHRoIC8gMyA6IGhlaWdodCAvIDM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gZGF0YS5lZGdlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBkYXRhLm5vZGVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbHVzdGVyTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2x1c3RlcklkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGVTZXAgPSAoTWF0aC5QSSAqIDIpIC8gbjtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBpICogYW5nbGVTZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkgKyBvcmlnaW5bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkgKyBvcmlnaW5bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsdXN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNsdXN0ZXIgJiYgY2x1c3Rlck1hcC5nZXQobm9kZS5jbHVzdGVyKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlck1hcC5zZXQobm9kZS5jbHVzdGVyLCBjbHVzdGVySWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBjbHVzdGVyTWFwLmdldChub2RlLmNsdXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmZpbGwgPSBjb2xvcnNbaWQgJSBjb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogY29sb3JzW2lkICUgY29sb3JzLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxhYmVsID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sYWJlbENmZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlOiBhbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQ2VudGVyOiAnbGVmdHRvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2UudHlwZSA9ICdxdWFkcmF0aWMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZU1hcC5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbm9kZU1hcC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5jb250cm9sUG9pbnRzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogb3JpZ2luWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBvcmlnaW5bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlLmNvbG9yID0gc291cmNlLnN0eWxlLmZpbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlLnNvdXJjZU5hbWUgPSBzb3VyY2UubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2UudGFyZ2V0TmFtZSA9IHRhcmdldC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBtYXAgdGhlIHZhbHVlIHRvIG5vZGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4VmFsdWUgPSAtOTk5OSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gOTk5OTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heFZhbHVlIDwgbi52YWx1ZSkgbWF4VmFsdWUgPSBuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pblZhbHVlID4gbi52YWx1ZSkgbWluVmFsdWUgPSBuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZVJhbmdlID0gWzMsIDMwXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZURhdGFSYW5nZSA9IFttaW5WYWx1ZSwgbWF4VmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZU5vZGVQcm9wKG5vZGVzLCAnc2l6ZScsICd2YWx1ZScsIHNpemVEYXRhUmFuZ2UsIHNpemVSYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguZGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGgucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNjYWxlTm9kZVByb3Aobm9kZXMsIHByb3BOYW1lLCByZWZQcm9wTmFtZSwgZGF0YVJhbmdlLCBvdXRSYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dExlbmd0aCA9IG91dFJhbmdlWzFdIC0gb3V0UmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGFSYW5nZVsxXSAtIGRhdGFSYW5nZVswXTtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIG5bcHJvcE5hbWVdID0gKChuW3JlZlByb3BOYW1lXSAtIGRhdGFSYW5nZVswXSkgKiBvdXRMZW5ndGgpIC8gZGF0YUxlbmd0aCArIG91dFJhbmdlWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2dyYXBoXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGlkPVwiY29udGFpbmVyXCIgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX0+PC9kaXY+XG4gICAgKTtcbn07XG5cblxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJHNiIsImNvbG9ycyIsImFyY0RpYWdyYW0iLCJwcm9wcyIsImFyY0RpYWdyYW1EYXRhIiwiYXJjRGlhZ3JhbVN0eWxlcyIsImFyY0RpYWdyYW1GdW5jdGlvbnMiLCJncmFwaCIsInNldEdyYXBoIiwic2NhbGVOb2RlUHJvcCIsIm5vZGVzIiwicHJvcE5hbWUiLCJyZWZQcm9wTmFtZSIsImRhdGFSYW5nZSIsIm91dFJhbmdlIiwib3V0TGVuZ3RoIiwiZGF0YUxlbmd0aCIsImZvckVhY2giLCJuIiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIndpZHRoIiwic2Nyb2xsV2lkdGgiLCJoZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJHcmFwaCIsImxpbmtDZW50ZXIiLCJtb2RlcyIsImRlZmF1bHQiLCJ0eXBlIiwiZm9ybWF0VGV4dCIsIm1vZGVsIiwidGV4dCIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiZGVmYXVsdE5vZGUiLCJzdHlsZSIsIm9wYWNpdHkiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJkZWZhdWx0RWRnZSIsInNpemUiLCJjb2xvciIsImxpbmVBcHBlbmRXaWR0aCIsIm9uIiwiZSIsImVkZ2UiLCJpdGVtIiwic2V0SXRlbVN0YXRlIiwid2luZG93Iiwib25yZXNpemUiLCJnZXQiLCJjaGFuZ2VTaXplIiwiZmV0Y2giLCJ0aGVuIiwicmVzIiwianNvbiIsImRhdGEiLCJvcmlnaW4iLCJyYWRpdXMiLCJlZGdlcyIsIm5vZGVNYXAiLCJNYXAiLCJjbHVzdGVyTWFwIiwiY2x1c3RlcklkIiwibGVuZ3RoIiwiYW5nbGVTZXAiLCJNYXRoIiwiUEkiLCJub2RlIiwiaSIsImFuZ2xlIiwieCIsImNvcyIsInkiLCJzaW4iLCJzZXQiLCJpZCIsImNsdXN0ZXIiLCJ1bmRlZmluZWQiLCJmaWxsIiwibGFiZWwiLCJuYW1lIiwibGFiZWxDZmciLCJwb3NpdGlvbiIsInJvdGF0ZSIsInJvdGF0ZUNlbnRlciIsInRleHRBbGlnbiIsInNvdXJjZSIsInRhcmdldCIsImNvbnRyb2xQb2ludHMiLCJtYXhWYWx1ZSIsIm1pblZhbHVlIiwidmFsdWUiLCJzaXplUmFuZ2UiLCJzaXplRGF0YVJhbmdlIiwicmVuZGVyIiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/metaverse-arc-diagram.js\n");

/***/ })

});